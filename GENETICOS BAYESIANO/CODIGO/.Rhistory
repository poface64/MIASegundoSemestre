adj = adj,
fitness = fitness
)
}
return(evaluada)
}
#### Seleccionar a los elites ####
# Entradas:
# poblacion_eval = Población ya evaluada con mdl
# pe = Porcentaje de elitismo (20%)
# Salida: Una lista de listas de los elites ordenados de menos a más mdl
seleccion = function(poblacion_eval, pe){
# Tamaño de la población
pobsize = length(poblacion_eval)
# Selección de cuantos de la elite seran seleccionados #
cantidad_elite = ceiling(pe*pobsize)
# Ordenarlos en función de su fitnes
ordenados = poblacion_eval[order(sapply(poblacion_eval, function(x) x$fitness))]
# Seleccionar a los elites
elites = ordenados[1:cantidad_elite]
# Devolver solo los indices elites
return(elites)
}
#### Generar las mutaciones ####
# Entradas:
# cantidad = Cantidad de sujetos mutantes a generar (pobsize*pm)
# n = cantidad de variables/nodos
# Salida: Una lista de listas de los sujetos mutantes
mutantes = function(cantidad, n){
# Vector de tamaño pobsize
mutantes = vector("list", cantidad)
# Aplicar sobre cada posible nuevo sujeto #
for (i in 1:cantidad) {
# Crea un sujeto nuevo
vec = sujeto(n)
# Guardaa su matriz de adyacencia decodificada
adj = decodificar(vec,umbral)
# Guardar los mutantes nuevos y sin evaluar#
mutantes[[i]] = list(
vector = vec,
adj = adj,
fitness = NA  # se evaluarán luego
)
}
return(mutantes)
}
#### Operador de cruza SESGADO ####
# Entradas:
# elite = lista de los sujetos elite elegidos
# no_elite = lista de los otros sujetos no elites
# rho = probabilidad de aceptar o no el valor de el padre elite
# Salida: Una lista de listas que contiene un hijo en vector
cruza = function(elite, no_elite, rho = 0.7){
#Verificar si las longitudes coinciden#
if (length(elite) != length(no_elite)) {
stop("Longitud de cromosomas no coincide")
}
# Se crea un vector vacio del tamaño de los padres #
hijo = numeric(length(elite))
# Para cada uno de los elementos del vector hijo
for (i in 1:length(elite)) {
# Si es menor que el umbral rho/p, toma del elite
if (runif(1) < rho) {
hijo[i] = elite[i]
# Si no, toma del no-elite
} else {
hijo[i] = no_elite[i]
}
}
return(hijo)
}
#### Generador de hijos con cruza sesgada ####
# Entradas:
# elite = lista de los sujetos elite elegidos
# no_elite = lista de los otros sujetos no elites
# Cantidad_hijos = cantidad de hijos a generar ()
# rho = probabilidad de aceptar o no el valor de el padre elite
# Salida: Una lista de listas que contiene un hijo en vector
generar_hijos = function(elites, no_elites, cantidad_hijos, rho = 0.7){
# Vector lista par guardar a los hijos #
hijos = vector("list", cantidad_hijos)
# Ciclo para cada uno de los posibles hijos #
for (i in 1:cantidad_hijos) {
# Seleccionar elite y no-elite al azar
elite = sample(elites, 1)[[1]]$vector
no_elite = sample(no_elites, 1)[[1]]$vector
# Crossover sesgado
hijo_vec = cruza(elite, no_elite, rho)
# Decodificación
hijo_adj = decodificar(hijo_vec,umbral)
# Guardar hijo (sin evaluar aún)
hijos[[i]] = list(
vector = hijo_vec,
adj = hijo_adj,
fitness = NA
)
}
return(hijos)
}
#### Crear a la siguiente generación ####
# Entradas:
# poblacion_eval = Población anterior evaluada
# n = cantidad de variables en la data
# tamaño_total = tamaño de la población
# porcentaje_elite = porcentaje de elitismo
# porcentaje_mutante = porcentaje de muta
# rho = probabilidad de aceptar o no el valor de el padre elite
# Salida: Una lista de listas que contiene a la nueva población
nuevapob = function(poblacion_eval, n,
tamano_total,porcentaje_elite = 0.2,
porcentaje_mutante = 0.2,rho = 0.7){
# Obtener la cantidad de sujetos elite
cantidad_elite = ceiling(porcentaje_elite * tamano_total)
# Definir la cantidad de mutantes
cantidad_mutante = ceiling(porcentaje_mutante * tamano_total)
# Definir la cantidad de hijos resultantes
cantidad_hijos = tamano_total - cantidad_elite - cantidad_mutante
# 1. Selección
elites = seleccion(poblacion_eval, porcentaje_elite)
no_elites = setdiff(poblacion_eval, elites)
# 2. Generación
hijos = generar_hijos (elites, no_elites, cantidad_hijos, rho = rho)
mutantes = mutantes(cantidad_mutante, n)
# 3. Unir todos
nueva_pob = c(elites, hijos, mutantes)
return(nueva_pob)
}
#### Ciclo del genetico ####
## Entrada
# data = X # Datos de entrada categoricos
# ngen = 20 # Numero de generaciones
# pobsize = 30 # Tamaño de la población
# pe = 0.2 # porcentaje de elitismo
# pm = 0.2 # porcentaje de muta
# rho = 0.7 # Probabilidad de escoger un cromosoma elite o no
# umbral = 0.5 # Decision para desfuzificar
# verbose = T # Ir mostrando en pantalla el registro
## Salida ##
# mejor = lista con el mejor sujeto encontrado
# historial = lista de los mejores encontrados a traves de las generaciones
algoritmo_genetico = function(data, ngen , pobsize ,
pe , pm ,
rho , umbral , verbose = TRUE) {
# Obtener la cantdad de datos
n = ncol(data)
# Obtener los nombres de la data
nombres = names(data)
# 1. Inicializar población
poblacion = pob(n, pobsize)
poblacion_eval = evaluarpob(poblacion, data, umbral)
# Guardar en un historial a los mejores por generación
historial_mejores = vector("list", ngen)
# Desde la gen 1 hasta la gen n-esima
gen = 1
for (gen in 1:ngen) {
# Mostrar en que generación vamos #
if (verbose) cat("Generación", gen, "\n")
# Guardar mejor individuo de esta generación
mejor = poblacion_eval[[which.min(sapply(poblacion_eval, function(x) x$fitness))]]
historial_mejores[[gen]] = mejor
# Crear a la nueva generación #
poblacion_nueva = nuevapob(poblacion_eval, n, pobsize,
pe, pm, rho)
# Evaluar a la nueva generación #
poblacion_eval = evaluarpob(lapply(poblacion_nueva, `[[`, "vector"), data, umbral)
}
# Extraer mejor de todos
fitness_todos = sapply(historial_mejores, function(x) x$fitness)
mejor_global = historial_mejores[[which.min(fitness_todos)]]
# Ponerle los nombres a la matriz de adyacencias final
colnames(mejor_global$adj) = colnames(mejor_global$adj) = nombres
# Devolver en forma de lista el mejor y el historial
return(list(
mejor = mejor_global,
historial = historial_mejores
))
}
#### Implementación del bucle de trabajo ####
ruta =  "C:\\Users\\Angel\\Desktop\\MIASegundoSemestre\\GENETICOS BAYESIANO\\BASES DEPURADAS\\10Zoo.csv"
# datos #
datos = cate(read.csv(ruta))
X = datos
data = X # Datos de entrada categoricos
ngen = 50 # Numero de generaciones
pobsize = 20 # Tamaño de la población
pe = 0.2 # porcentaje de elitismo
pm = 0.2 # porcentaje de muta
rho = 0.7 # Probabilidad de escoger un cromosoma elite o no
umbral = 0.5 # Decision para desfuzificar
verbose = T # Ir mostrando en pantalla el registro
alpha = 100000
# Ciclo del genetico #
resultado = algoritmo_genetico(data, ngen , pobsize ,
pe , pm ,
rho , umbral,alpha, verbose = TRUE)
# Ciclo del genetico #
resultado = algoritmo_genetico(data, ngen , pobsize ,
pe , pm ,
rho , umbral, verbose = TRUE)
g = graph_from_adjacency_matrix(adj, mode = "directed")
plot(g, vertex.size = 30, edge.arrow.size = 0.5)
g = graph_from_adjacency_matrix(resultado$mejor$adj, mode = "directed")
plot(g, vertex.size = 30, edge.arrow.size = 0.5)
plot(sapply(resultado$historial, function(x) x$fitness), type = "l", ylab = "Fitness (MDL)", xlab = "Generación")
#### Implementación del bucle de trabajo ####
ruta =  "C:\\Users\\Angel\\Desktop\\MIASegundoSemestre\\GENETICOS BAYESIANO\\BASES DEPURADAS\\1IrisD.csv"
# datos #
datos = cate(read.csv(ruta))
X = datos
data = X # Datos de entrada categoricos
ngen = 50 # Numero de generaciones
pobsize = 20 # Tamaño de la población
pe = 0.2 # porcentaje de elitismo
pm = 0.2 # porcentaje de muta
rho = 0.7 # Probabilidad de escoger un cromosoma elite o no
umbral = 0.5 # Decision para desfuzificar
verbose = T # Ir mostrando en pantalla el registro
alpha = 100000
###
# Generar sujeto
suj = sujeto(ncol(X))
# Decodificarlo y revisar si hay ciclo
adj = decodificar(suj)
g = graph_from_adjacency_matrix(adj, mode = "directed")
plot(g, vertex.size = 30, edge.arrow.size = 0.5)
###
# Generar sujeto
#suj = sujeto(ncol(X))
# Decodificarlo y revisar si hay ciclo
#adj = decodificar(suj)
#g = graph_from_adjacency_matrix(adj, mode = "directed")
#plot(g, vertex.size = 30, edge.arrow.size = 0.5)
detectar_ciclo(adj)  # Debe devolver FALSE
# Ciclo del genetico #
resultado = algoritmo_genetico(data, ngen , pobsize ,
pe , pm ,
rho , umbral, verbose = TRUE)
g = graph_from_adjacency_matrix(adj, mode = "directed")
#g = graph_from_adjacency_matrix(adj, mode = "directed")
g = graph_from_adjacency_matrix(resultado$mejor$adj, mode = "directed")
plot(g, vertex.size = 30, edge.arrow.size = 0.5)
plot(sapply(resultado$historial, function(x) x$fitness), type = "l", ylab = "Fitness (MDL)", xlab = "Generación")
resultado$mejor$fitness
# Ciclo del genetico #
resultado = algoritmo_genetico(data, ngen , pobsize ,
pe , pm ,
rho , umbral, verbose = TRUE)
#g = graph_from_adjacency_matrix(adj, mode = "directed")
g = graph_from_adjacency_matrix(resultado$mejor$adj, mode = "directed")
plot(g, vertex.size = 30, edge.arrow.size = 0.5)
resultado$mejor$fitness
# Ciclo del genetico #
resultado = algoritmo_genetico(data, ngen , pobsize ,
pe , pm ,
rho , umbral, verbose = TRUE)
#g = graph_from_adjacency_matrix(adj, mode = "directed")
g = graph_from_adjacency_matrix(resultado$mejor$adj, mode = "directed")
plot(g, vertex.size = 30, edge.arrow.size = 0.5)
resultado$mejor$fitness
#### Implementación del bucle de trabajo ####
ruta =  "C:\\Users\\Angel\\Desktop\\MIASegundoSemestre\\GENETICOS BAYESIANO\\BASES DEPURADAS\\2PalmerPenD.csv"
# datos #
datos = cate(read.csv(ruta))
X = datos
data = X # Datos de entrada categoricos
ngen = 50 # Numero de generaciones
pobsize = 20 # Tamaño de la población
pe = 0.2 # porcentaje de elitismo
pm = 0.2 # porcentaje de muta
rho = 0.7 # Probabilidad de escoger un cromosoma elite o no
umbral = 0.5 # Decision para desfuzificar
verbose = T # Ir mostrando en pantalla el registro
alpha = 100000
###
# Generar sujeto
#suj = sujeto(ncol(X))
# Decodificarlo y revisar si hay ciclo
#adj = decodificar(suj)
#g = graph_from_adjacency_matrix(adj, mode = "directed")
#plot(g, vertex.size = 30, edge.arrow.size = 0.5)
#detectar_ciclo(adj)  # Debe devolver FALSE
# Ciclo del genetico #
resultado = algoritmo_genetico(data, ngen , pobsize ,
pe , pm ,
rho , umbral, verbose = TRUE)
#g = graph_from_adjacency_matrix(adj, mode = "directed")
g = graph_from_adjacency_matrix(resultado$mejor$adj, mode = "directed")
plot(g, vertex.size = 30, edge.arrow.size = 0.5)
resultado$mejor$fitness
#### Implementación del bucle de trabajo ####
ruta =  "C:\\Users\\Angel\\Desktop\\MIASegundoSemestre\\GENETICOS BAYESIANO\\BASES DEPURADAS\\2PalmerPenD.csv"
# datos #
datos = cate(read.csv(ruta))
X = datos
data = X # Datos de entrada categoricos
ngen = 50 # Numero de generaciones
pobsize = 20 # Tamaño de la población
pe = 0.2 # porcentaje de elitismo
pm = 0.2 # porcentaje de muta
rho = 0.7 # Probabilidad de escoger un cromosoma elite o no
umbral = 0.5 # Decision para desfuzificar
verbose = T # Ir mostrando en pantalla el registro
alpha = 100000
###
# Generar sujeto
#suj = sujeto(ncol(X))
# Decodificarlo y revisar si hay ciclo
#adj = decodificar(suj)
#g = graph_from_adjacency_matrix(adj, mode = "directed")
#plot(g, vertex.size = 30, edge.arrow.size = 0.5)
#detectar_ciclo(adj)  # Debe devolver FALSE
# Ciclo del genetico #
resultado = algoritmo_genetico(data, ngen , pobsize ,
pe , pm ,
rho , umbral, verbose = TRUE)
#g = graph_from_adjacency_matrix(adj, mode = "directed")
g = graph_from_adjacency_matrix(resultado$mejor$adj, mode = "directed")
plot(g, vertex.size = 30, edge.arrow.size = 0.5)
resultado$mejor$fitness
#### Implementación del bucle de trabajo ####
ruta =  "C:\\Users\\Angel\\Desktop\\MIASegundoSemestre\\GENETICOS BAYESIANO\\BASES DEPURADAS\\2PalmerPenD.csv"
# datos #
datos = cate(read.csv(ruta))
X = datos
data = X # Datos de entrada categoricos
ngen = 50 # Numero de generaciones
pobsize = 20 # Tamaño de la población
pe = 0.2 # porcentaje de elitismo
pm = 0.2 # porcentaje de muta
rho = 0.7 # Probabilidad de escoger un cromosoma elite o no
umbral = 0.5 # Decision para desfuzificar
verbose = T # Ir mostrando en pantalla el registro
alpha = 100000
###
# Generar sujeto
#suj = sujeto(ncol(X))
# Decodificarlo y revisar si hay ciclo
#adj = decodificar(suj)
#g = graph_from_adjacency_matrix(adj, mode = "directed")
#plot(g, vertex.size = 30, edge.arrow.size = 0.5)
#detectar_ciclo(adj)  # Debe devolver FALSE
# Ciclo del genetico #
resultado = algoritmo_genetico(data, ngen , pobsize ,
pe , pm ,
rho , umbral, verbose = TRUE)
#g = graph_from_adjacency_matrix(adj, mode = "directed")
g = graph_from_adjacency_matrix(resultado$mejor$adj, mode = "directed")
plot(g, vertex.size = 30, edge.arrow.size = 0.5)
resultado$mejor$fitness
plot(sapply(resultado$historial, function(x) x$fitness), type = "l", ylab = "Fitness (MDL)", xlab = "Generación")
resultado$historial
# Ciclo del genetico #
resultado = algoritmo_genetico(data, ngen , pobsize ,
pe , pm ,
rho , umbral, verbose = TRUE)
#g = graph_from_adjacency_matrix(adj, mode = "directed")
g = graph_from_adjacency_matrix(resultado$mejor$adj, mode = "directed")
resultado$mejor$fitness
par(mfrow = c(2,1))
plot(g, vertex.size = 30, edge.arrow.size = 0.5)
plot(g, vertex.size = 30, edge.arrow.size = 0.5)
plot(g, vertex.size = 30, edge.arrow.size = 0.5)
plot(sapply(resultado$historial, function(x) x$fitness), type = "l", ylab = "Fitness (MDL)", xlab = "Generación")
resultado$mejor$fitness
# Decodificarlo y revisar si hay ciclo
#adj = decodificar(suj)
#g = graph_from_adjacency_matrix(adj, mode = "directed")
#plot(g, vertex.size = 30, edge.arrow.size = 0.5)
#detectar_ciclo(adj)  # Debe devolver FALSE
# Ciclo del genetico #
resultado = algoritmo_genetico(data, ngen , pobsize ,
pe , pm ,
rho , umbral, verbose = TRUE)
#g = graph_from_adjacency_matrix(adj, mode = "directed")
g = graph_from_adjacency_matrix(resultado$mejor$adj, mode = "directed")
resultado$mejor$fitness
plot(g, vertex.size = 30, edge.arrow.size = 0.5)
plot(sapply(resultado$historial, function(x) x$fitness), type = "l", ylab = "Fitness (MDL)", xlab = "Generación")
#### Implementación del bucle de trabajo ####
ruta =  "C:\\Users\\Angel\\Desktop\\MIASegundoSemestre\\GENETICOS BAYESIANO\\BASES DEPURADAS\\3WinesD.csv"
# datos #
datos = cate(read.csv(ruta))
X = datos
data = X # Datos de entrada categoricos
ngen = 50 # Numero de generaciones
pobsize = 20 # Tamaño de la población
pe = 0.2 # porcentaje de elitismo
pm = 0.2 # porcentaje de muta
rho = 0.7 # Probabilidad de escoger un cromosoma elite o no
umbral = 0.5 # Decision para desfuzificar
verbose = T # Ir mostrando en pantalla el registro
alpha = 100000
###
# Generar sujeto
#suj = sujeto(ncol(X))
# Decodificarlo y revisar si hay ciclo
#adj = decodificar(suj)
#g = graph_from_adjacency_matrix(adj, mode = "directed")
#plot(g, vertex.size = 30, edge.arrow.size = 0.5)
#detectar_ciclo(adj)  # Debe devolver FALSE
# Ciclo del genetico #
resultado = algoritmo_genetico(data, ngen , pobsize ,
pe , pm ,
rho , umbral, verbose = TRUE)
#g = graph_from_adjacency_matrix(adj, mode = "directed")
g = graph_from_adjacency_matrix(resultado$mejor$adj, mode = "directed")
resultado$mejor$fitness
plot(g, vertex.size = 30, edge.arrow.size = 0.5)
plot(sapply(resultado$historial, function(x) x$fitness), type = "l", ylab = "Fitness (MDL)", xlab = "Generación")
#### Implementación del bucle de trabajo ####
ruta =  "C:\\Users\\Angel\\Desktop\\MIASegundoSemestre\\GENETICOS BAYESIANO\\BASES DEPURADAS\\4HeartAttacksD.csv"
# datos #
datos = cate(read.csv(ruta))
X = datos
data = X # Datos de entrada categoricos
ngen = 50 # Numero de generaciones
pobsize = 20 # Tamaño de la población
pe = 0.2 # porcentaje de elitismo
pm = 0.2 # porcentaje de muta
rho = 0.7 # Probabilidad de escoger un cromosoma elite o no
umbral = 0.5 # Decision para desfuzificar
verbose = T # Ir mostrando en pantalla el registro
alpha = 100000
###
# Generar sujeto
#suj = sujeto(ncol(X))
# Decodificarlo y revisar si hay ciclo
#adj = decodificar(suj)
#g = graph_from_adjacency_matrix(adj, mode = "directed")
#plot(g, vertex.size = 30, edge.arrow.size = 0.5)
#detectar_ciclo(adj)  # Debe devolver FALSE
# Ciclo del genetico #
resultado = algoritmo_genetico(data, ngen , pobsize ,
pe , pm ,
rho , umbral, verbose = TRUE)
#g = graph_from_adjacency_matrix(adj, mode = "directed")
g = graph_from_adjacency_matrix(resultado$mejor$adj, mode = "directed")
resultado$mejor$fitness
plot(g, vertex.size = 30, edge.arrow.size = 0.5)
plot(sapply(resultado$historial, function(x) x$fitness), type = "l", ylab = "Fitness (MDL)", xlab = "Generación")
resultado$mejor$fitness
# Convertir la matriz a un objeto bn
vars <- colnames(data)
vars
dag <- empty.graph(nodes = vars)
###########
library(bnlearn)
install.packages("bnlearn")
###########
library(bnlearn)
# Convertir la matriz a un objeto bn
vars <- colnames(data)
dag <- empty.graph(nodes = vars)
amat(dag) <- resultado$mejor$adj
dag
# Calcular el score (MDL ~ BIC)
return(-score(dag, data = data, type = "bic"))
# Calcular el score (MDL ~ BIC)
-score(dag, data = data, type = "bic")
#### Aprender los parametros con bnlearn ####
mejor_adj = resultado$mejor$adj
mejor_adj
bn_estructura <- empty.graph(nodes = colnames(mejor_adj))
bn_estructura
amat(bn_estructura) <- mejor_adj
# Aprender
bn_entrenada <- bn.fit(bn_estructura, data, method = "bayes")  # puedes usar "mle" o "bayes"
bn_entrenada
X[,-ncol(X)]
names(X)
###  Clasificar ####
nuevos_datos = X[,-ncol(X)]
# Predecir Class
predicciones <- predict(bn_entrenada, node = "Class", data = nuevos_datos, method = "bayes-lw")
# Predecir Class
predicciones <- predict(bn_entrenada, node = "class", data = nuevos_datos, method = "bayes-lw")
predicciones
### Hacer la matriz de confusión ###
table(real = X$class,
Pred = predicciones)
#### Implementación del bucle de trabajo ####
ruta =  "C:\\Users\\Angel\\Desktop\\MIASegundoSemestre\\GENETICOS BAYESIANO\\BASES DEPURADAS\\10Zoo.csv"
# datos #
datos = cate(read.csv(ruta))
X = datos
data = X # Datos de entrada categoricos
ngen = 50 # Numero de generaciones
pobsize = 20 # Tamaño de la población
pe = 0.2 # porcentaje de elitismo
pm = 0.2 # porcentaje de muta
rho = 0.7 # Probabilidad de escoger un cromosoma elite o no
umbral = 0.5 # Decision para desfuzificar
verbose = T # Ir mostrando en pantalla el registro
alpha = 100000
# Ciclo del genetico #
resultado = algoritmo_genetico(data, ngen , pobsize ,
pe , pm ,
rho , umbral, verbose = TRUE)
#g = graph_from_adjacency_matrix(adj, mode = "directed")
g = graph_from_adjacency_matrix(resultado$mejor$adj, mode = "directed")
resultado$mejor$fitness
plot(g, vertex.size = 30, edge.arrow.size = 0.5)
plot(sapply(resultado$historial, function(x) x$fitness), type = "l", ylab = "Fitness (MDL)", xlab = "Generación")
plot(g, vertex.size = 30, edge.arrow.size = 0.5)
?graph_from_adjacency_matrix
learning.test
###
bn_pc <- pc.stable(datos, alpha = 0.05)
bn_pc
print(bn_pc)
plot(bn_pc)
install.packages("Rgraphviz")
