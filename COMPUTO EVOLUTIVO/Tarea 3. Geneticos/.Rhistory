knitr::opts_chunk$set(echo = F,
warning = F,
message = F)
# Definimos la función con D=10
f <- function(x) {
D <- length(x)
if (D != 10) {
stop("El vector de entrada debe tener 10 dimensiones.")
}
sum(x^2)
}
# Rangos para x1 y x2
x1 <- seq(-10, 10, length.out = 50)
x2 <- seq(-10, 10, length.out = 50)
# Creamos una matriz para almacenar los valores de la función
z <- matrix(NA, nrow = length(x1), ncol = length(x2))
z
# Fijamos las otras 8 dimensiones en 0 y calculamos los valores de f(x)
for (i in 1:length(x1)) {
for (j in 1:length(x2)) {
x <- rep(0, 10)
x[1] <- x1[i]
x[2] <- x2[j]
z[i, j] <- f(x)
}
}
# Graficamos la superficie 3D
library(plotly)
install.packages("plotly")
# Graficamos la superficie 3D
library(plotly)
plot_ly(x = x1, y = x2, z = z, type = "surface") %>%
layout(
title = "f(x1, x2, 0, ..., 0) = x1^2 + x2^2",
scene = list(
xaxis = list(title = "x1"),
yaxis = list(title = "x2"),
zaxis = list(title = "f(x)")
)
)
# Definimos la función con D=10
f <- function(x) {
D <- length(x)
if (D != 10) {
stop("El vector de entrada debe tener 10 dimensiones.")
}
sum(x^2)
}
# Rangos para x1 y x2
x1 <- seq(-10, 10, length.out = 50)
x2 <- seq(-10, 10, length.out = 50)
# Creamos una matriz para almacenar los valores de la función
z <- matrix(NA, nrow = length(x1), ncol = length(x2))
# Fijamos las otras 8 dimensiones en 0 y calculamos los valores de f(x)
for (i in 1:length(x1)) {
for (j in 1:length(x2)) {
x <- rep(0, 10)
x[1] <- x1[i]
x[2] <- x2[j]
z[i, j] <- f(x)
}
}
# Graficamos la superficie 3D usando rgl
library(rgl)
install.packages("rgl")
# Graficamos la superficie 3D usando rgl
library(rgl)
# Abre una nueva ventana gráfica
open3d()
# Crea la superficie
surface3d(x1, x2, z, color = "lightblue", alpha = 0.8)
# Añade ejes y etiquetas
axes3d(labels = c("x1", "x2", "f(x)"))
title3d(main = "f(x1, x2, 0, ..., 0) = x1^2 + x2^2", col = "black")
# Definimos la función con D=10
f <- function(x) {
D <- length(x)
if (D != 10) {
stop("El vector de entrada debe tener 10 dimensiones.")
}
sum(x^2)
}
# Rangos para x1 y x2
x1 <- seq(-10, 10, length.out = 50)
x2 <- seq(-10, 10, length.out = 50)
# Creamos una matriz para almacenar los valores de la función
z <- matrix(NA, nrow = length(x1), ncol = length(x2))
# Fijamos las otras 8 dimensiones en 0 y calculamos los valores de f(x)
for (i in 1:length(x1)) {
for (j in 1:length(x2)) {
x <- rep(0, 10)
x[1] <- x1[i]
x[2] <- x2[j]
z[i, j] <- f(x)
}
}
# Graficamos la superficie 3D
library(plotly)
plot_ly(x = x1, y = x2, z = z, type = "surface") %>%
layout(
title = "f(x1, x2, 0, ..., 0) = x1^2 + x2^2",
scene = list(
xaxis = list(title = "x1"),
yaxis = list(title = "x2"),
zaxis = list(title = "f(x)")
)
)
plot_ly(x = x1, y = x2, z = z, type = "surface") %>%
layout(
title = "f(x) = x_1²+x_2²  ",
scene = list(
xaxis = list(title = "x1"),
yaxis = list(title = "x2"),
zaxis = list(title = "f(x)")
)
)
plot_ly(x = x1, y = x2, z = z, type = "surface",
colorscale = list(c(0, "red"), c(1, "blue"))) %>%
layout(
title = "f(x) = x_1²+x_2²  ",
scene = list(
xaxis = list(title = "x1"),
yaxis = list(title = "x2"),
zaxis = list(title = "f(x)")
)
)
plot_ly(x = x1, y = x2, z = z, type = "surface",
colorscale = list(c(0, "red"), c(1, "blue"))) %>%
layout(
title = list(
text = "$f(x_1, x_2) = x_1^2 + x_2^2$",
mathjax = TRUE),
scene = list(
xaxis = list(title = "x1"),
yaxis = list(title = "x2"),
zaxis = list(title = "f(x)")
)
)
plot_ly(x = x1, y = x2, z = z, type = "surface",
colorscale = list(c(0, "red"), c(1, "blue"))) %>%
layout(
title = list(
text = "$f(x_1, x_2) = x_1^2 + x_2^2$",
mathjax = TRUE
),
scene = list(
xaxis = list(title = "x1"),
yaxis = list(title = "x2"),
zaxis = list(title = "f(x)")
)
)
plot_ly(x = x1, y = x2, z = z, type = "surface",
colorscale = list(c(0, "red"), c(1, "blue"))) %>%
layout(
title = paste0("f(x<sub>1</sub>, x<sub>2</sub>) = x<sub>1</sub><sup>2</sup> + x<sub>2</sub><sup>2</sup>"),
scene = list(
xaxis = list(title = "x1"),
yaxis = list(title = "x2"),
zaxis = list(title = "f(x)")
)
)
reticulate::repl_python()
function(X){
# Cada valor al cuadrado se eleva y se suma.
res = sum(X^2)
return(res)
}
reticulate::repl_python()
#### Función del problema 2
# Entrada: un vector de 10 valores reales entre -5.12 y 5.12.
X = rep(0,10)
# PARTE CONSTANTE
D = length(X)
D
cos(pi)
sin(pi)
sin(0)
cos(0)
cos(pi/2)
sin(pi/2)
2*pi
X
sin(2*pi*X)
# Parte de la suma de cosenos
cos(2*pi*X)
fx = function(X){
# PARTE CONSTANTE
D = length(X)
dc = 10*D
# Parte de la suma de cosenos
pc = sum(X^2 - 10*cos(2*pi*X))
# Resultado
res = dc + pc
return(res)
}
#### Función del problema 2
# Entrada: un vector de 10 valores reales entre -5.12 y 5.12.
X = rep(0,10)
# PARTE CONSTANTE
D = length(X)
dc = 10*D
dc
# Parte de la suma de cosenos
pc = sum(X^2 - 10*cos(2*pi*X))
pc
# Resultado
res = dc + pc
res
